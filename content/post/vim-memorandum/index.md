---
title: "オレオレVimワザ備忘録"
date: 2019-04-26T19:05:24-04:00
description: "Vim docを読んだことをまとめました。Vimの中級者が上級者にステップアップするときに参考になるかと思います"
# banner:"/img/some.png"
# lead: "Example lead - highlighted near the title"
# disable_comments: true # Optional, disable Disqus comments if true
disable_profile: true # no one wants to see my profile while reading articles
# authorbox: true # Optional, enable authorbox for specific post
# mathjax: true # Optional, enable MathJax for specific post
categories:
  - "技術"
  - "備忘録"
tags:
  - "Vim"
# menu: main # Optional, add page to a menu. Options: main, side, footer
---

最近Vimのチュートリアルを読むのにハマっており、標準でもかなりの数の便利な機能があることを知った。

だが普段は使わないものも多く、読んだだけでは忘れそうなのでここにメモしておく。読み進めるに連れ更新するかもしれない。

「Vimで一通り編集はできるけど、もっとバリバリ高速に編集できる上級者目指したいな」という方に役に立つかもしれない~~が普通にVimdoc読んだほうが網羅的だ~~。

# 注意
この記事の内容は公開されている[vimdoc-ja](https://vim-jp.org/vimdoc-ja/)の焼き直しなので、この記事の内容について一切の権利を主張するものではなく、それらは全て[vim-jp.org](https://vim-jp.org/)に帰属する。

以下、`<C-x>`は「`Ctrl`キーをおしながら`x`」


# Visualモードで逆側に跳ぶ
`o`で逆側に跳ぶ。矩形選択モードのときは`O`で同じ行の反対側に跳ぶ。

# 置換モードでフォーマットを保つ
`r`で一文字置換し、`R`で置換モードに入れるが、そのまえに`g`を押す（`gR`など）と字をずらさないように置換してくれる。

具体的にはタブ文字を置換した場合や全角文字を半角文字で置換した場合にいい感じに文字位置がずれないようにしてくれる。

# マニュアル
`K`でVimのマニュアルが出るのは有名だが、`<Leader>K`でカーソル下の単語に対して`man`コマンドを呼び出せる。Cとかシェルスクリプトを書いてる時便利。

*	`<Leader>`は初期状態なら`\`

# 大文字小文字の変更

`gu``gU`で小文字・大文字に変更、`g~`で入れ替え。

# コマンドの範囲指定のやりかたまとめ

4つある。

1.	`{Visual}[cmd]`とするとVisualモードで選んだ範囲に対してコマンドを適用。

	*	例、`V4jd`で現在行および下4行を削除

	*	特に、`<C-v>`で矩形選択し、`I`で行頭入力をすると、`<Esc>`で抜けた瞬間に選択範囲全てに入力できる。

2.	移動コマンド（または[テキストオブジェクト](#テキストオブジェクト)）を`{motion}`と呼ぶことにする。`[cmd]{motion}`とすると、`{motion}`の範囲にコマンドを適用。

	*	例、`dG`でファイルの最後まで削除
	*	例、`de`で単語の終わりまで削除

	*	またこの前に回数を指定できる。

		*	例、`3dw`で三単語削除

3.	コマンド（またはコマンドの最後の文字）を二回繰り返すと、現在行に対して適用する。
	*	例、`dd`で現在行を削除
	*	例、`gugu`または`guu`で現在行の大文字を全て小文字に

4.	一部のコマンドは大文字で入力することでカーソル位置から行末まで適用できる。
	*	例、`D`で行末まで削除

# Exコマンドの範囲指定のやりかたまとめ

Exコマンドとは`:`から始まるコマンドのこと。`:`の後に`{number},{number}`で行数を指定してもよい。最初の行は1から始まり、最後の行は`$`で表される。

`%`はすべての行を表すので、`1,$`に等しい。また現在行は`.`

1行だけ指定したいときは`:{number}[cmd]`とする。

*	例、`:.p`:	現在行を表示

*	例、`:30p`:	30行目を表示

*	例、`:1,$join`または`:%join`:	ファイル全体を1行にする

注、以上の例ではコマンドを入力したあとに押すべき`<Enter>`を省略している。以下も同様である。

注、行数を指定していない場合、現在行にのみ適用されるか全体に適用されるかはコマンドによる。例えば[`:substitute`](#%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%AB%E5%90%88%E8%87%B4%E3%81%97%E3%81%9F%E3%81%A8%E3%81%93%E3%82%8D%E3%82%92%E7%BD%AE%E6%8F%9B%E3%81%99%E3%82%8B-substitute)は現在行にのみ、`:write`は全体に適用される。

## マーク
`ma``mC`のように`m{alphabet}`とすることでその行を記憶でき、`'a` `'C`で戻れる。
`` `a ``のようにbacktickで戻ることもでき、その場合行頭に戻る代わりにマークした文字にきちんともどる（これを好んで``:map ' ` ``のようにする人もいる、backtickはUSキーボードでは遠いので）。

このマークは`{number}`の代わりに行数指定に使える。

Exコマンドは[普通のコマンド](#コマンドの範囲指定のやりかたまとめ)と同じようにVisualモードで選択した範囲に適用することもできる。Visualモードで選択後、そのまま`:`を押せばよい。

その場合、自動的に`'<,'>:`が出てくるが、実は`'<``'>`がそれぞれ選択範囲の最初・最後の行を表すマークである。

## 行の検索

`{number}`の代わりに`?pattern?`で現在行からの前方（上方向への）検索、`/pattern/`で後方検索ができる。

*	例、`:?<head>?,/<\/head>/join`:	（今headの中ににいるとして）headの中身を1行にする[^not in head]

[^not in head]:普通のhtmlファイルならheadはひとつしかないので、実際にはheadの中にいなかったとしても空気を読んで動いてくれる。2つ以上あったら「『最初のheadの後ろの`</head>`』と『あとのheadの最初の`<head>`』があるから、逆向きなら行けるんだけどどうする？」って訊かれる。

# シェルコマンドの実行まとめ

Normalモードで、`:!ls`のようにしてシェルコマンドを実行できる。

また、`:r ![shell_cmd]`でシェルコマンドの標準出力を読み込み、`:w ![shell_cmd]`で逆にシェルコマンドの標準入力にテキスト（の全体）を書き込める

*	例、`:w !wc`でテキストの行数・単語数・文字数をカウント

標準入力を受け取って、なにか処理をして標準出力に返すシェルコマンドを`[filter]`と呼ぶことにする。

*	Normalモードで`!{motion}[filter]`か、`{Visual}![filter]`とするとその範囲の行を切り取ってシェルコマンドに投げ、返事をその場所に書き込む。

	*	例、`V!xxd`:	現在行を16進数に変換 (hexdump)
	*	例、`gg!Gxxd`:	ファイル全体を16進数に変換（最初の`gg`はあくまで移動で、`G`が`{motion}`であることに注意）

*	また、【`![filter]`というExコマンド】というふうに解釈し、[行数指定](#exコマンドの範囲指定のやりかたまとめ)をかけてやることもできる。

	*	例、`:%!sort`:	ファイル全体を行単位でソート
		*	`!sort`というExコマンドに`%`行指定をかけたと考えよう

	*	例、`:%!sort|uniq`:	ファイル全体を行単位でソートし、複数ある行は1つに絞る

	*	例題

		```MakeFile
		OBJS = \
			version.o \
			pch.o \
			getopt.o \
			util.o \
			getopt1.o \
			inp.o \
			patch.o \
			backup.o
		```
		の2行目以降のファイルのリストをソートせよ（実際には、その後バックスラッシュを適切に付け直す必要がある）

*	`!![filter]`で現在行に対して行う。`dd`とかと[似てる](#コマンドの範囲指定のやりかたまとめ)ね。

	*	例、`!!date`:	現在行が今の日付と時刻で置換される（`date`コマンドは標準入力を無視して現在の時刻を返すため）。
		*	`:read !date`は挿入するのに対し、こちらは置換する。

# テキストオブジェクト

テキストのカタマリを扱えるマクロのようなもの。`a某`か`i某`の場合が多く、それぞれaroundとinsideを意味していると思われる。

例えば、`ip`はinside paragraphで段落。英語の文章に対して`dip`でパラグラフを消せる。便利すぎワロタ

より一般的には、上で`{motion}`と書いてあるところに使うことができる。

つまり、`d{textobj}`とか`!{textobj}[shell_cmd]`とか。

また、`v{textobj}`で選んで`:`とすればExコマンドにも使える。

他にどんなテキストオブジェクトがあるのかは`:h objects`を読む。

# 前回選択したVisualモードの場所
`gv`

同じ場所を繰り返しVisualモードで選択したい時、たとえば同じ場所を何度も[substitute](#%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%AB%E5%90%88%E8%87%B4%E3%81%97%E3%81%9F%E3%81%A8%E3%81%93%E3%82%8D%E3%82%92%E7%BD%AE%E6%8F%9B%E3%81%99%E3%82%8B-substitute)したいときに使える（[例](https://vim-jp.org/vimdoc-ja/usr_26.html#26.1)）

# コマンドライン補完
`:`でコマンドを打っている途中、`<C-d>`で現在時点での補完候補を一覧できる。

`<Tab>`で補完できる。`<C-p>``<C-n>`で補完候補を選択できる。補完したは良いものの、別の候補が出てきてしまったのでやり直したい場合はその場で`<C-p>`

矢印キー上下で過去のコマンドを探せる(シェルと似た動作)が、`:se<Up>`のようにすると、`:se`から始まる過去のコマンドを探せる。

# コマンドラインウィンドウ

`q:`で過去のコマンドが一覧できるモードに入る。Normalモードなので、そのまま`k`で移動してエンターで過去のコマンドを探し、編集したり実行したりできる。前のコマンドを効率的に探したいときに便利

# サスペンド

`<C-z>`でVimを一時停止してシェルに戻る。`fg`でVimに戻る。


# URLを開く

URLの上で`gf`。ダウンロードしてVimで表示してくれる。ちなみに、シェルからでも`ftp`, `scp`, `rcp`, `http`等のファイルを指定すれば勝手にダウンロードして開いてくれる。
Vimに通信機能があるわけではなく`scp`や`wget`のような外部プログラムを使っているらしい。

例:
```shell
vim https://vim-jp.org
```
エラーが起きたときにはエラーメッセージが出ることもあるが、単に何も表示されないだけだったりすることもある。エラーの原因を特定するのは難しいので、手作業でダウンロードしよう

また、Cのライブラリなど一部のものについても空気を読んで該当するローカルファイルを読んでくれることもある。

# 誤タイプの自動修正

`:iabbrev itn int`で`itn`が`int`に自動で変わる[^why abbrev]。

誤タイプの癖を`.vimrc`に書いておこう。

[^why abbrev]:(insert mode) abbreviationの略で、もともとは`iabbrev ad advertisement`のように省略形を登録するものだった

# 現在のカーソルの場所の情報
`<C-g>`でカーソルの場所がファイル内でどのあたりかを表示する。

`g<C-g>`でよりたくさんの情報を表示する。

特にバイト単位の位置も表示されるので、300バイト目に移動したいとき`300go`などと組み合わせて使える。

`ga`で現在のカーソル位置の文字の情報を表示する。

# 普通打てない文字を直接入力する
`<C-v>`の後に文字を入力するか、3ケタの数字を入力することで普通は打てない文字を打てる。例えば`<C-v><Esc>`でエスケープ文字を、`<C-v>009`でタブ文字を入力できる（`<Tab>`のASCIIコードが9なので）

数字の前に`o`で8進数を、`u`と`U`でそれぞれ16ビットと32ビットの文字コードを入力できる。

例
`<C-v>o123`
`<C-v>u1234`
`<C-v>U12345678`

# Normalモードコマンド

`<C-o>`で1コマンドだけNormalモードに戻って実行し、インサートモードに戻る。

# バイナリファイルをいじる

`vim -b datafile`でバイナリモードで起動でき、ｲｲｶﾝｼﾞの設定を施した状態で起動する。

印字不可能文字は`:set display=uhex`で16進数表記することもできる。

改行が少なく折り返しが多い場合は`:set nowrap`が有効。

`:%!xxd`でhexdumpできる。このコマンドの意味がわからない時は[ここ](シェルコマンドの実行まとめ)を読む	

また、下のようにすると`*.bin`ファイルを開いた時に自動で`xxd`したりともっとｲｲｶﾝｼﾞにしてくれる。

```init.vim
augroup Binary
    au!
	" この設定が嫌になったらこの下の行をコメントアウトすればすべて止まる
	" もちろん全部コメントアウトしてもいいが
    au BufReadPre  *.bin let &bin=1

    au BufReadPost *.bin if &bin | %!xxd
    au BufReadPost *.bin set ft=xxd | endif

    au BufWritePre *.bin if &bin | %!xxd -r
    au BufWritePre *.bin endif

    au BufWritePost *.bin if &bin | %!xxd
    au BufWritePost *.bin set nomod | endif
augroup END
```

# テキストを自動整形する
`:set textwidth=30`で30文字に達したら自動で改行するようにする。ただし、空白でしか改行しないので英語のドキュメントなどを書くときなどに使う機能だろう。

すでに書かれたテキストを整形したくなったら変更したい範囲を囲んで`gq`を使う。たとえば`V4jgq`など。

もしくは、`gq`のあとにテキストオブジェクトを指定してもよい。`ap`でパラグラフになるので、`gqap`でパラグラフを整形する。

`:center 40`, `:right 40`で`:set textwidth=40`だったものとして中央揃え、右揃えできる。数字がない場合`textwidth`の値がそのまま使われる。
これらも、変更したい範囲を囲んでから実行することができる。`V4j:center 100`など。

# 左右にスクロールする
`zh``zl`で左右にスクロール。
`zH``zL`でウィンドウの半分だけスクロール。
`ze``zs`でカーソル位置が画面端になるようにスクロール。

# パターンに合致した行にコマンドを実行する(`:global`)

`:g/{pattern}/[cmd]`
で`{pattern}`にマッチした行すべてに`[cmd]`を実行する。

（`[cmd]`が指定されなかったら`:p`（表示するだけ）を実行する）

例えば、[テキストの自動整形](./#テキストを自動整形する)によって特定文字数に達したときに勝手に改行が挿入されてしまっているファイルに対し、

>次のコマンドでそれぞれの段落を一行につなげることができます:
>
>`:g/./,/^$/join`
>
>すこし複雑ですね[^what's join]。分解して説明します:
>
>        :g/./           一文字以上の文字を含んでいる行を探す":global"コマンド
>             ,/^$/      現在行(非空行)から空行までの範囲を指定
>                  join  指定された範囲の行を ":join" コマンドで一行につなげる

これでもまだややこしいのでもう少し説明しよう。

このコマンドは、[Exコマンドの行指定](#exコマンドの範囲指定のやりかたまとめ)で書いた、`{number},{number}`のフォーマットで言うと`:{1文字以上含んでいる全ての行},{空行}join`と解釈できる。

`{1文字以上含んでいる全ての行}`を`g/./`で、`{空行}`を`/^$/`で[検索している](./#行の検索)のだ
（`^`は行頭を、`$`は行末を表すので、`^$`は「行頭直後に行末」、すなわち空行となる）。

「空白のみがある行」も空行と捉えたい場合は、空白文字が`\s`、「直前の文字が0個以上」が`*`なので、
`^\s*$`とすればよい。すなわち、`:g/\S/,/^\s*$/join`

この場合、`set textwidth=0`としたあとでファイル全体に`gq`をすることに等しい。

[^what's join]:`join`コマンドを使った経験がないとわかりにくいだろう。適当なファイルで`v4j:join<Enter>`などやって遊んでみてほしい。

また、`:g!`か`:v`で「パターンに合致しなかった行」にコマンドを実行できる。`g:`と組み合わせて、パターンを絞り込める。

*	例、`:g/Heisei/g!/Reiwa/`:	`Heisei`という文字列を含むが`Reiwa`という文字列を含まない行を取り出す
*	この場合も、`与式`=`:{Heiseiが含まれる行}g!/Reiwa/p`=`:{Heiseiが含まれるがReiwaが含まれない行}p`と解釈していけば、ただの`:p`コマンドに対する[行数指定](#exコマンドの範囲指定のやりかたまとめ)だとわかる。

# パターンに合致したところを置換する(`:substitute`)

`:s/{pattern}/{string}/[flags]`で`{pattern}`を見つけて`{string}`に直す。

*	例、`:s/Heisei/Reiwa/`:	`Heisei`を`Reiwa`に直す

*	例、`:s/[Hh]eisei/Reiwa/`:	`Heisei`に加え`heisei`も`Reiwa`に直す


注意、これは現在行にしか行わない。全体にかけたい場合は`:%s/...`とする（[なぜ？](#exコマンドの範囲指定のやりかたまとめ)）

*	発展例、`:%s/\s\+$//`:	ファイル全体に対し行末の空白文字を消す

注意、これは行あたり1回しか置換しない。例えば`Heisei`が同じ行に2回以上出てきても頭の1回しか置換しない。全て置換したい場合は`g`フラグをつける(`s/[Hh]eisei/Reiwa/g`)

*	例、`:%s/four/4/g`
	*	これはよく考えると正しく動作しない。`thirtyfour`が`thirty4`に変換されてしまう。
	*	こうする`:%s/\<four\>/4/g`:	`\<``\>`が単語の先頭と末尾にヒットする
	*	このようにうまく動作させられる場合もあるが、そうでなかったら`c`フラグを付けて一つ一つチェックしていくのがいいだろう

*	`n`フラグを付けると「調査だけするが実際には置換しない」
	*	例、`:%s/.//gn`:	改行以外のすべての文字を消す……と思いきや何もしない
		*	副作用としてパターンのヒット回数（今回だと文字数）をカウントできる（ログとして表示されるので）
			*	例、`:%s/\<the\>//gn`:	テキスト中に出てくる`the`の数を数える


*	その他にも様々なフラグがあるので`:h :s`を読もう

`{string}`には`&`を使える。これは`{pattern}`でマッチした文字

`:&`:	前にやったsubstituteをもう一回やる。

*	注、範囲は保存されない。↑だと現在行に対してのみ行われる。
*	注、フラグは保存されない。フラグも同じにしたい場合は`:&&`

また、`:s`と`:g`コマンドについて、`/`で区切ったが、これ以外の文字で区切ることもできる。

*	ただし、アルファベット、数字、`\`,`"`,`|`は使えない。
*	`/`を含む文字列を検索したいときに便利である。例えば`+`や`!`がよく使われる。

# 複数のファイルに対してコマンドを実行する
`:args {filename}`でファイルを引数リストに加える

*	`{filename}`にはワイルドカードも使えるので、実行したいファイルをすべて含むようにする。`args`を実行した時点で1つ目のファイルが開く。

そして、`:argdo [cmd]`でそれらに対して実行。

*	例、 `:args ./*``:argdo %s/\<some_word\>/alt_word/ge | update`
	*	`some_word`を`alt_word`に置き換え
	*	`e`フラグで、あるファイルに置いて`some_word`が見つからなくてもエラーを出させない
		*	`argdo`がエラーによって途中で止まるのを防ぐ
	*	`update`で変更があったときにだけファイルを保存

*	cf.	`:windo`,`:bufdo`

# 標準入力から読み込む

Vimを起動するときに、ファイルが入るべき場所に`-`を指定してやることで標準入力をそのまま編集できる。

例、`ls | vim -`:	`ls`の出力結果をファイルに保存することなくそのまま編集する
