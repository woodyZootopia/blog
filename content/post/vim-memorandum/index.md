---
title: "オレオレVimワザ備忘録"
date: 2019-04-26T19:05:24-04:00
description: "Vim docを読んで新鮮だったことをまとめました。Vimの中級者が上級者にステップアップするときに参考になるかと思います"
# banner:"/img/some.png"
# lead: "Example lead - highlighted near the title"
# disable_comments: true # Optional, disable Disqus comments if true
disable_profile: true # no one wants to see my profile while reading articles
# authorbox: true # Optional, enable authorbox for specific post
# mathjax: true # Optional, enable MathJax for specific post
categories:
  - "技術"
  - "備忘録"
tags:
  - "Vim"
# menu: main # Optional, add page to a menu. Options: main, side, footer
---

最近Vimのチュートリアルを読むのにハマっており、標準でもかなりの数の便利な機能があることを知った。

だが普段は使わないものも多く、読んだだけでは忘れそうなのでここにメモしておく。読み進めるに連れ更新するかもしれない。

「Vimで一通り編集はできるけど、もっとバリバリ高速に編集できる上級者目指したいな」という方に役に立つかもしれない~~が普通にVimdoc読んだほうが網羅的だ~~。

# 注意
この記事の内容は公開されている[vimdoc-ja](https://vim-jp.org/vimdoc-ja/)の焼き直しなので、この記事の内容について一切の権利を主張するものではなく、それらは全て[vim-jp.org](https://vim-jp.org/)に帰属する。

以下、`<C-x>`は「`Ctrl`キーをおしながら`x`」

# 前にいた場所に移動

`<C-o>`で前にいた場所に移動、`<Tab>`=`<C-i>`[^why equal]で逆に移動。

[^why equal]:シェルにおいて`<Tab>`と`<C-i>`はおなじ。なのでこれらを別にマッピングすることはできない

# Visualモードで逆側に跳ぶ
`o`で逆側に跳ぶ。矩形選択モードのときは`O`で同じ行の反対側に跳ぶ（左右の移動）。

# 置換モードでフォーマットを保つ
`r`で一文字置換し、`R`で置換モードに入れるが、そのまえに`g`を押す（`gR`など）と字をずらさないように置換してくれる。

具体的にはタブ文字を置換した場合や全角文字を半角文字で置換した場合に、いい感じに文字位置がずれないようにしてくれる。

# マニュアル
`K`でVimのマニュアルが出るのは有名だが、`<Leader>K`でカーソル下の単語に対して`man`コマンドを呼び出せる。Cとかシェルスクリプトを書いてる時便利。

*	`<Leader>`は初期状態なら`\`

# 大文字小文字の変更

`gu``gU`で小文字・大文字に変更、`g~`で入れ替え。

`g?`でシーザー暗号化。CTFくらいでしか使わなさそう。

# コマンドの範囲指定のやりかたまとめ

4つある。

1.	`{Visual}[cmd]`とするとVisualモードで選んだ範囲に対してコマンドを適用。

	*	例、`V4jd`で現在行および下4行を削除

	*	特に、`<C-v>`で矩形選択し、`I`で行頭入力をすると、`<Esc>`で抜けた瞬間に選択範囲全てに入力できる。

2.	移動コマンド（または[テキストオブジェクト](#テキストオブジェクト)）を`{motion}`と呼ぶことにする。`[cmd]{motion}`とすると、`{motion}`の範囲にコマンドを適用。

	*	例、`dG`でファイルの最後まで削除
	*	例、`de`で単語の終わりまで削除

	*	またこの前に回数を指定できる。

		*	例、`3dw`で三単語削除

3.	コマンド（またはコマンドの最後の文字）を二回繰り返すと、現在行に対して適用する。
	*	例、`dd`で現在行を削除
	*	例、`gugu`または`guu`で現在行の大文字を全て小文字に

4.	一部のコマンドは大文字で入力することでカーソル位置から行末まで適用できる。
	*	例、`D`で行末まで削除

# Exコマンドの範囲指定のやりかたまとめ

Exコマンドとは`:`から始まるコマンドのこと。`:`の後に`{number},{number}`で行数を指定してもよい。最初の行は1から始まり、最後の行は`$`で表される。

`%`はすべての行を表すので、`1,$`に等しい。また現在行は`.`

1行だけ指定したいときは`:{number}[cmd]`とする。

*	例、`:30p`:	30行目を表示

*	例、`:.p`:	現在行を表示

*	例、`:1,$join`または`:%join`:	ファイル全体を1行にする
	*	Exコマンドの`join`はノーマルモードコマンドの`J`と同じなので、`ggVGJ`も同じ効果を持つ。

注、以上の例ではコマンドを入力したあとに押すべき`<Enter>`を省略している。以下も同様である。

注、行数を指定していない場合、現在行にのみ適用されるか全体に適用されるかはコマンドによる。例えば[`:substitute`](#%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%AB%E5%90%88%E8%87%B4%E3%81%97%E3%81%9F%E3%81%A8%E3%81%93%E3%82%8D%E3%82%92%E7%BD%AE%E6%8F%9B%E3%81%99%E3%82%8B-substitute)は現在行にのみ、`:write`は全体に適用される。

## マーク
`ma``mC`のように`m{alphabet}`とすることでその行を記憶でき、`'a` `'C`で戻れる。
`` `a ``のようにbacktickで戻ることもでき、その場合行頭に戻る代わりにマークした文字にきちんともどる（これを好んで``:map ' ` ``のようにする人もいる、backtickはUSキーボードでは遠いので）。

このマークは`{number}`の代わりに行数指定に使える。

さて、Exコマンドは[普通のコマンド](#コマンドの範囲指定のやりかたまとめ)と同じようにVisualモードで選択した範囲に適用することもできる。Visualモードで選択後、そのまま`:`を押せばよい。
その場合、自動的に`:'<,'>`が出てくるが、実は`'<``'>`がそれぞれ選択範囲の最初・最後の行を表すマークなのである。

## 行の検索

`{number}`の代わりに`?pattern?`で現在行からの前方（上方向への）検索、`/pattern/`で後方検索ができる。

*	例、`:?<head>?,/<\/head>/join`:	（今headの中ににいるとして）headの中身を1行にする

# シェルコマンドの実行まとめ

Normalモードで、`:!ls`のようにしてシェルコマンドを実行できる。

また、`:r ![shell_cmd]`でシェルコマンドの標準出力を読み込み、`:w ![shell_cmd]`で逆にシェルコマンドの標準入力にテキスト（の全体）を書き込める

*	例、`:w !wc`でテキストの行数・単語数・文字数をカウント

標準入力を受け取って、なにか処理をして標準出力に返すシェルコマンドを`[filter]`と呼ぶことにする。

*	Normalモードで`!{motion}[filter]`か、`{Visual}![filter]`とするとその範囲の行を切り取ってシェルコマンドに投げ、返事をその場所に書き込む。

	*	例、`V!xxd`:	現在行を16進数に変換 (hexdump)
	*	例、`gg!Gxxd`:	ファイル全体を16進数に変換（最初の`gg`はあくまで移動で、`G`が`{motion}`であることに注意）

*	また、【`![filter]`というExコマンド】というふうに解釈し、[行数指定](#exコマンドの範囲指定のやりかたまとめ)をかけてやることもできる。

	*	例、`:%!sort`:	ファイル全体を行単位でソート
		*	`!sort`というExコマンドに`%`行指定をかけたと考えよう

	*	例、`:%!sort|uniq`:	ファイル全体を行単位でソートし、複数ある行は1つに絞る

	*	例題

		```MakeFile
		OBJS = \
			version.o \
			pch.o \
			getopt.o \
			util.o \
			getopt1.o \
			inp.o \
			patch.o \
			backup.o
		```
		の2行目以降のファイルのリストをソートせよ（実際には、その後バックスラッシュを適切に付け直す必要がある）

*	`!![filter]`で現在行に対して行う。`dd`とかと[似てる](#コマンドの範囲指定のやりかたまとめ)ね。

	*	例、`!!date`:	現在行が今の日付と時刻で置換される（`date`コマンドは標準入力を無視して現在の時刻を返すため）。
		*	`:read !date`は挿入するのに対し、こちらは置換する。

# テキストオブジェクト

テキストのカタマリを扱えるマクロのようなもの。`a某`か`i某`の場合が多く、それぞれaroundとinsideを意味していると思われる。

例えば、`ip`はinside paragraphで段落。英語の文章に対して`dip`でパラグラフを消せる。便利すぎワロタ

より一般的には、上で`{motion}`と書いてあるところに使うことができる。

つまり、`d{textobj}`とか`!{textobj}[shell_cmd]`とか。

また、`v{textobj}`で選んで`:`とすればExコマンドにも使える。

他にどんなテキストオブジェクトがあるのかは`:h objects`を読む。

# 前回選択したVisualモードの場所
`gv`

同じ場所を繰り返しVisualモードで選択したい時、たとえば同じ場所を何度も[substitute](#%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%AB%E5%90%88%E8%87%B4%E3%81%97%E3%81%9F%E3%81%A8%E3%81%93%E3%82%8D%E3%82%92%E7%BD%AE%E6%8F%9B%E3%81%99%E3%82%8B-substitute)したいときに使える（[例](https://vim-jp.org/vimdoc-ja/usr_26.html#26.1)）

# コマンドライン補完
`:`でコマンドを打っている途中、`<C-d>`で現在時点での補完候補を一覧できる。

`<Tab>`で補完できる。`<C-p>``<C-n>`で補完候補を選択できる。補完したは良いものの、別の候補が出てきてしまったのでやり直したい場合はその場で`<C-p>`

矢印キー上下で過去のコマンドを探せる(シェルと似た動作)が、`:se<Up>`のようにすると、`:se`から始まる過去のコマンドを探せる。

# コマンドラインウィンドウ

`q:`で過去のコマンドが一覧できるモードに入る。Normalモードなので、そのまま`k`で移動してエンターで過去のコマンドを探し、編集したり実行したりできる。前のコマンドを効率的に探したいときに便利。

**あくまで別ウィンドウで開かれたNormalモードであるので、このウィンドウを消さない限り`<Esc>`をおしても離脱できない**。`<Esc>`を押せばなんとかなると思ってる多くの初心者を屠ってきた（と勝手に思ってる）

# サスペンド

`<C-z>`でVimを一時停止してシェルに戻る。`fg`でVimに戻る。


# URLを開く

URLの上で`gf`。ダウンロードしてVimで表示してくれる。ちなみに、シェルからでも`ftp`, `scp`, `rcp`, `http`等のファイルを指定すれば勝手にダウンロードして開いてくれる。
Vimに通信機能があるわけではなく`scp`や`wget`のような外部プログラムを使っているらしい。

例:
```shell
vim https://vim-jp.org
```
エラーが起きたときにはエラーメッセージが出ることもあるが、単に何も表示されないだけだったりすることもある。エラーの原因を特定するのは難しいので、手作業でダウンロードしよう

また、Cのライブラリなど一部のものについても空気を読んで該当するローカルファイルを読んでくれることもある。

# 誤タイプの自動修正

`:iabbrev itn int`で`itn`が`int`に自動で変わる[^why abbrev]。

`:imap itn int`でも同じような効果が起こる。だが、前者だと`itn<Space>`などと単語の終わりであることを明示する入力をして初めて`int<Space>`に書き換わるのに対し、こちらは`itn`と打った瞬間に書き換わる。

`itn`のように打ち間違いでもない限り打つことのない単語を入力する際は後者を使ってもよいが、一般に前者が便利だろう。ただし、`map`は`ab`と違い複数回のマップが可能。『マップしたものからマップしたい』場合は`map`を使おう。

誤タイプの癖を`.vimrc`に書いておこう。
他にも、例えばC/C++によるプログラミングにおける略記に以下が使える。


```ftplugin/c.vim
" long long
" これは下に示すようにpairから使われるのでabでなくmapにしている
imap ll long long

iab li long int
iab lli long long

" unsigned
iab uint unsigned int
iab ul unsigned long
iab ull unsigned long long

" misspelled
iab itn int
```

```ftplugin/cpp.vim
" 上の設定を読み込む
source <sfile>:p:h/c_kyopro.vim

" pair
iab pint pair<int, int>
iab plong pair<long, long>
iab pii pair<int, int>
iab pli pair<ll, int>
iab pil pair<int, ll>
iab pll pair<ll, ll>

" abbr
iab pq priority_queue
iab mp make_pair
```

[^why abbrev]:(insert mode) abbreviationの略で、もともとは`iabbrev ad advertisement`のように省略形を登録するものだった

# 現在のカーソルの場所の情報
`<C-g>`でカーソルの場所がファイル内でどのあたりかを表示する。

`g<C-g>`でよりたくさんの情報を表示する。

特にバイト単位の位置も表示されるので、300バイト目に移動したいとき`300go`などと組み合わせて使える。

`ga`で現在のカーソル位置の文字の情報を表示する。

# 普通打てない文字を直接入力する
`<C-v>`の後に文字を入力するか、3ケタの数字を入力することで普通は打てない文字を打てる。例えば`<C-v><Esc>`でエスケープ文字を、`<C-v>009`でタブ文字を入力できる（`<Tab>`のASCIIコードが9なので）

数字の前に`o`で8進数を、`u`と`U`でそれぞれ16ビットと32ビットの文字コードを入力できる。

例
`<C-v>o123`
`<C-v>u1234`
`<C-v>U12345678`

# Normalモードコマンド

`<C-o>`で1コマンドだけNormalモードに戻って実行し、インサートモードに戻る。

# バイナリファイルをいじる

`vim -b datafile`でバイナリモードで起動でき、ｲｲｶﾝｼﾞの設定を施した状態で起動する。

印字不可能文字は`:set display=uhex`で16進数表記することもできる。

改行が少なく折り返しが多い場合は`:set nowrap`が有効。

`:%!xxd`でhexdumpできる。このコマンドの意味がわからない時は[ここ](シェルコマンドの実行まとめ)を読む	

また、下のようにすると`*.bin`ファイルを開いた時に自動で`xxd`したりともっとｲｲｶﾝｼﾞにしてくれる。

```init.vim
augroup Binary
    au!
	" この設定が嫌になったらこの下の行をコメントアウトすればすべて止まる
	" もちろん全部コメントアウトしてもいいが
    au BufReadPre  *.bin let &bin=1

    au BufReadPost *.bin if &bin | %!xxd
    au BufReadPost *.bin set ft=xxd | endif

    au BufWritePre *.bin if &bin | %!xxd -r
    au BufWritePre *.bin endif

    au BufWritePost *.bin if &bin | %!xxd
    au BufWritePost *.bin set nomod | endif
augroup END
```

# テキストを自動整形する
`:set textwidth=30`で30文字に達したら自動で改行するようにする。ただし、空白でしか改行しないので英語のドキュメントなどを書くときなどに使う機能だろう。

すでに書かれたテキストを整形したくなったら変更したい範囲を囲んで`gq`を使う。たとえば`V4jgq`など。

もしくは、`gq`のあとにテキストオブジェクトを指定してもよい。`ap`でパラグラフになるので、`gqap`でパラグラフを整形する。

`:center 40`, `:right 40`で`:set textwidth=40`だったものとして中央揃え、右揃えできる。数字がない場合`textwidth`の値がそのまま使われる。
これらも、変更したい範囲を囲んでから実行することができる。`V4j:center 100`など。

# 左右にスクロールする
`zh``zl`で左右にスクロール。
`zH``zL`でウィンドウの半分だけスクロール。
`ze``zs`でカーソル位置が画面端になるようにスクロール。

# パターンに合致した行にExコマンドを実行する(`:global`)

`:g/{pattern}/[cmd]`
で`{pattern}`にマッチした行すべてに`[cmd]`を実行する。

`[cmd]`が指定されなかったら`:p`（表示するだけ）を実行する[^unix trivia]。

[^unix trivia]:Unixにおける`grep`コマンドは`:g/re/p`から来ている。`re`はregular expressionの略

例えば、[テキストの自動整形](./#テキストを自動整形する)によって特定文字数に達したときに勝手に改行が挿入されてしまっているファイルに対し、

>次のコマンドでそれぞれの段落を一行につなげることができます:
>
>`:g/./,/^$/join`
>
>すこし複雑ですね[^what's join]。分解して説明します:
>
>        :g/./           一文字以上の文字を含んでいる行を探す":global"コマンド
>             ,/^$/      現在行(非空行)から空行までの範囲を指定
>                  join  指定された範囲の行を ":join" コマンドで一行につなげる

これでもまだややこしいのでもう少し説明しよう。

このコマンドは、[Exコマンドの行指定](#exコマンドの範囲指定のやりかたまとめ)で書いた、`{number},{number}`のフォーマットで言うと`:{1文字以上含んでいる全ての行},{空行}join`と解釈できる。

`{1文字以上含んでいる全ての行}`を`g/./`で、`{空行}`を`/^$/`で[検索している](./#行の検索)のだ
（`^`は行頭を、`$`は行末を表すので、`^$`は「行頭直後に行末」、すなわち空行となる）。

「空白のみがある行」も空行と捉えたい場合は、空白文字が`\s`、「直前の文字が0個以上」が`*`なので、
`^\s*$`とすればよい。すなわち、`:g/\S/,/^\s*$/join`

この場合、`set textwidth=0`としたあとでファイル全体に`gq`をすることに等しい。

[^what's join]:`join`コマンドを使った経験がないとわかりにくいだろう。適当なファイルで`v4j:join<Enter>`などやって遊んでみてほしい。

また、`:g!`か`:v`で「パターンに合致しなかった行」にコマンドを実行できる。`g:`と組み合わせて、パターンを絞り込める。

*	例、`:g/Heisei/g!/Reiwa/`:	`Heisei`という文字列を含むが`Reiwa`という文字列を含まない行を取り出す
*	この場合も、`与式`=`:{Heiseiが含まれる行}g!/Reiwa/p`=`:{Heiseiが含まれるがReiwaが含まれない行}p`と解釈していけば、ただの`:p`コマンドに対する[行数指定](#exコマンドの範囲指定のやりかたまとめ)だとわかる。

# パターンに合致したところを置換する(`:substitute`)

`:s/{pattern}/{string}/[flags]`で`{pattern}`を見つけて`{string}`に直す。

*	例、`:s/Heisei/Reiwa/`:	`Heisei`を`Reiwa`に直す

*	例、`:s/[Hh]eisei/Reiwa/`:	`Heisei`に加え`heisei`も`Reiwa`に直す


注意、これは現在行にしか行わない。全体にかけたい場合は`:%s/...`とする（[なぜ？](#exコマンドの範囲指定のやりかたまとめ)）

*	発展例、`:%s/\s\+$//`:	ファイル全体に対し行末の空白文字を消す

注意、これは行あたり1回しか置換しない。例えば`Heisei`が同じ行に2回以上出てきても頭の1回しか置換しない。全て置換したい場合は`g`フラグをつける(`s/[Hh]eisei/Reiwa/g`)

*	例、`:%s/four/4/g`
	*	これはよく考えると正しく動作しない。`thirtyfour`が`thirty4`に変換されてしまう。
	*	こうする`:%s/\<four\>/4/g`:	`\<``\>`が単語の先頭と末尾にヒットする
	*	このようにうまく動作させられる場合もあるが、そうでなかったら`c`フラグを付けて一つ一つチェックしていくのがいいだろう

*	`n`フラグを付けると「調査だけするが実際には置換しない」
	*	例、`:%s/.//gn`:	改行以外のすべての文字を消す……と思いきや何もしない
		*	副作用としてパターンのヒット回数（今回だと文字数）をカウントできる（ログとして表示されるので）
			*	例、`:%s/\<the\>//gn`:	テキスト中に出てくる`the`の数を数える


*	その他にも様々なフラグがあるので`:h :s`を読もう

`{string}`には`&`を使える。これは`{pattern}`でマッチした文字

*	例、`:%s/Kojima\( Hideo\)\=/& Kantoku`で、`Kojima`または`Kojima Hideo`の後に`<Space>Kantoku`をつける

`:&`:	前にやったsubstituteをもう一回やる。

*	注、範囲は保存されない。`:&`だと現在行に対してのみ行われるので、`:%&`とする。
*	注、フラグは保存されない。フラグも同じにしたい場合は`:&&`

また、`:s`と`:g`コマンドについて、`/`で区切ったが、これ以外の文字で区切ることもできる。

*	ただし、アルファベット、数字、`\`,`"`,`|`は使えない。
*	`/`を含む文字列を検索したいときに便利である。例えば`+`や`!`がよく使われる。

# 複数のファイルに対してコマンドを実行する
`:args {filename}`でファイルを引数リストに加える

*	`{filename}`にはワイルドカードも使えるので、実行したいファイルをすべて含むようにする。`args`を実行した時点で1つ目のファイルが開く。

そして、`:argdo [cmd]`でそれらに対して実行。

*	例、 `:args ./*``:argdo %s/\<some_word\>/alt_word/ge | update`
	*	`some_word`を`alt_word`に置き換え
	*	`e`フラグで、あるファイルにおいて`some_word`が見つからなくてもエラーを出させない
		*	`argdo`がエラーによって途中で止まるのを防ぐ
	*	`update`で変更があったときにだけファイルを保存

*	cf.	`:windo`,`:bufdo`

# 標準入力から読み込む

Vimを起動するときに、ファイルが入るべき場所に`-`を指定してやることで標準入力をそのまま編集できる。

例、`ls | vim -`:	`ls`の出力結果をファイルに保存することなくそのまま編集する

# レジスタとは
レジスタとは要するにクリップボードのようなもので、Vimでは編集アクションの種類ごとに別のレジスタに保存されている。

`:reg`でレジスタを一覧で見ることができ、`"<alphabet>`をコマンドの直前に指定することで`<alphabet>`レジスタにその結果を保存できる。
大文字のアルファベットの場合、レジスタを書き換える代わりに追記する。

*	例、`"a3yy`で3行ヤンクしてレジスタ`a`に保存。`"ap`でその内容をペースト。
*	例、別の場所で`"Ayy`してレジスタ`a`に追記。
*	例、`qa`でレジスタ`a`にコマンドマクロを保存。`@a`でその内容を実行。

主要なレジスタは以下の通り。

| レジスタ名        | 意味                                                                                              |
| ------------      | ----------------                                                                                  |
| "                 | 無名レジスタ。直前のヤンク・削除など(`d``c``s``x``y`)が（レジスタを指定しなかった場合）入っている |
| 一桁の数字        | 無名レジスタの履歴                                                                                |
| %                 | 現在のファイル名                                                                                  |
| *                 | クリップボードの内容                                                                              |
| /                 | 最後の検索内容                                                                                    |
| :                 | 最後のコマンドラインの内容<br>特に、`@:`で直前のコマンドをもう一度実行                            |
| -（マイナス）     | 最後の1行未満の削除の内容                                                                         |
| .（ドット）       | 最後に挿入された内容。インサートモードで`<C-a>`としたときに入力されるものに同じ                   |
| =                 | Expressionレジスタ。式を計算できる                                                                |
| _（アンダーバー） | ブラックホール。書き込めるが取り出すことができない。[^how to use underscore register]             |

[^how to use underscore register]:例えば、`nnoremap x "_x`で`x`によって消された内容が無名レジスタに残らなくなる。

## レジスタの内容を挿入（インサートモード）
インサートモードで`<C-r>`の後にレジスタ名を入力することでレジスタの内容を挿入できる。

*	例、`<C-r>=32*8`で256が挿入される

## レジスタの内容をコマンドに使う

基本的にはインサートモードのときと同じだが、`%`の後に以下の順で修飾子をつけることができる。

| 修飾子       | 意味                                                                   |
| ------------ | ----------------                                                       |
| `:p`         | 最初に置く。絶対パスにする。                                           |
| `:~`         | ホームディレクトリからの相対パスにする。                               |
| `:.`         | 現在ディレクトリからの相対パスにする。                                 |
| `:h`         | ディレクトリ名 (head)                                                  |
| `:t`         | ファイル名 (tail)                                                      |
| `:r`         | ファイル名の拡張子以外 (root)                                          |
| `:e`         | ファイル名の拡張子(extension)                                          |
| `:S`         | 特殊文字が含まれていた場合、シェルコマンドで使えるようにエスケープする |

`:p``:~``:.`は併用しない。 `:h``:t``:r``:e`は併用しない。

例、`:!mkdir %:p:h:S/new`でカレントディレクトリ内に`new`という新しいディレクトリを作る

# Makeコマンドによるコンパイル・デバッグ
Cなどのコンパイル言語は、ファイルを分割してリンカでつないでプログラミングすることも多く、そのとき一部のファイルしか更新していない場合に全てをコンパイルし直すのは無意味である。そのため、`make`というコマンドを使うことで、更新した部分のみコンパイルし直すことができる。`MakeFile`というファイルを使うことで、どのファイルがどのファイルに依存しているかを書くことができるが、その書き方についてはここでは詳しくは解説しない。

重要なのは、Vimにも`:make`コマンドがあるということである。ただ`make`するだけではなく、強力なデバッグ支援機能を持つ。

というのも、これを使うと、**コンパイルエラーの出た行がVimの`Quickfix`というリストに登録される**。`Quickfix`は`:cn``:cN`というコマンドで前後に行き来したり、`:copen`というコマンドでエラー一覧を表示したりできる。

ただし、QuickfixはVim全体で共有されてしまう。そのため、複数のプロジェクトを同時に編集しているときなどに不便だと思った場合は、windowそれぞれが別のQuickfixリストを持つことができる`location-list`という機能がある。
これには`:lmake`で登録され、`:ln``:lN`で行き来できる。

おすすめ設定は以下:

```init.vim
" quickfix jump
nnoremap [q :cprevious<CR>   
nnoremap ]q :cnext<CR>       
nnoremap [Q :<C-u>cfirst<CR> 
nnoremap ]Q :<C-u>clast<CR>  

"window-local quickfix jump
nnoremap [w :lprevious<CR>   
nnoremap ]w :lnext<CR>       
nnoremap [W :<C-u>lfirst<CR> 
nnoremap ]W :<C-u>llast<CR>  
```

`set makeprg=...`でコマンドを変更できる。

# ファイルを横断した検索
ファイルを横断して検索するには、`:vimgrep`と`:grep`の方法がある。

`:vimgrep`はあまり速くないが、Vim内部で動いているので、Vimの正規表現などが使える。

`:grep`は外部のシェルコマンドを呼び出しており、その結果を表示している。好きなコマンドを使えるので、パフォーマンス・仕様に応じて自由に選べるのがメリット。

シェルコマンドの側はVimが受け付けられる形式で検索結果を返す必要があるが、本家`grep`でなくても、有名どころはだいたいがその形式に対応しているので検索すればわかるだろう。
自分は[ripgrep](https://github.com/BurntSushi/ripgrep)を使っているので、時間がかかることが多そうな再帰的検索にはこちらを使うようにしている。

```init.vim
" grep
nnoremap <leader>vv :lvimgrep! //j %:p:h/*<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

" recursive search
set grepprg=rg\ --vimgrep\ --no-heading " 外部grepコマンドとそのオプションを指定
nnoremap <leader>vr :lgrep 
" 上行は行末にスペースが有る
```

なお、これらの検索結果もQuickfixリストに格納される。上の設定では`location-list`に格納するようになっているが。

# Undoツリー
VimではUndoしてから変更した場合はツリー構造になって内部に保存されている。`u`や`<C-r>`ではそのツリー構造をたどり、`g-``g+`では単純に変更時間の前後でたどる。特定の時間の状況に戻りたい場合は、`:earlier 30m``:later 40s`などで戻れる。これらに単なる数字を指定すると変更回数と解釈されるので注意。

`:undolist`でこれまでのundoの一覧を見られる。

